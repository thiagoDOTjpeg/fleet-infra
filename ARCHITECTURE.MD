# üèóÔ∏è Arquitetura do Sistema - Plataforma Log√≠stica

Este documento detalha as decis√µes de arquitetura, stack tecnol√≥gico e estrat√©gias de dados adotadas para o desenvolvimento da plataforma de entregas.

## 1. Contexto do Sistema (C4 Model - N√≠vel 1)

Vis√£o macro das intera√ß√µes entre os usu√°rios, a plataforma e sistemas externos.

```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#fff', 'edgeLabelBackground':'#ffffff', 'tertiaryColor': 'transparent', 'background': 'transparent', 'lineColor': '#000'}}}%%
graph TD
    classDef person fill:#08427b,stroke:#052e56,color:#fff,rx:10,ry:10;
    classDef system fill:#1168bd,stroke:#0b4884,color:#fff,rx:10,ry:10;
    classDef external fill:#999999,stroke:#6b6b6b,color:#fff,rx:10,ry:10;

    User[("Cliente / Entregador")]:::person
    Admin[("Administrador")]:::person

    System[("Plataforma de Log√≠stica")]:::system

    Maps[("Open Street Map")]:::external

    User -->|"Usa o App para pedidos/entregas"| System
    Admin -->|"Gerencia opera√ß√µes"| System

    System -->|"Geocodifica√ß√£o e Rotas"| Maps
```

## 2. Arquitetura T√©cnica (C4 Model - N√≠vel 2)

O sistema segue uma arquitetura de Microsservi√ßos orientada a eventos.
O fluxo de dados prioriza:

### Seguran√ßa no edge (API Gateway)

### Performance na escrita de geolocaliza√ß√£o (Write-Behind)

```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#fff', 'edgeLabelBackground':'#ffffff', 'tertiaryColor': 'transparent', 'background': 'transparent', 'lineColor': '#ffffff'}}}%%
graph TD
    %% --- Defini√ß√£o de Estilos (Classes) ---
    classDef frontend fill:#e1bee7,stroke:#4a148c,stroke-width:2px,color:#000,rx:10,ry:10;
    classDef gateway fill:#37474f,stroke:#000,stroke-width:2px,color:#fff,shape:hexagon;
    classDef javaSvc fill:#bbdefb,stroke:#0d47a1,stroke-width:2px,color:#000;
    classDef nodeSvc fill:#c8e6c9,stroke:#1b5e20,stroke-width:2px,color:#000;
    classDef phpSvc fill:#ffe0b2,stroke:#e65100,stroke-width:2px,color:#000;
    classDef database fill:#cfd8dc,stroke:#455a64,stroke-width:2px,color:#000,shape:cylinder;
    classDef queue fill:#fff9c4,stroke:#fbc02d,stroke-width:2px,color:#000,stroke-dasharray: 5 5;

    %% --- Estrutura do Diagrama ---
    subgraph Clients ["üì± Frontends (SPA Angular)"]
        direction LR
        MobileApp("App (Cliente/Entregador)")
        AdminWeb("Backoffice Web (Admin)")
    end

    subgraph Edge ["üõ°Ô∏è Edge Layer"]
        Nginx{{"API Gateway (Nginx)"}}
    end

    subgraph Services ["‚öôÔ∏è Backend Microservices"]
    subgraph Data ["üíæ Persistence & Messaging"]
        Redis[("Redis (Cache & Buffer)")]
        RabbitMQ[["RabbitMQ (Events)"]]
        DB_Core[("DB_Orders (Postgres)")]
        DB_Geo[("DB_Tracking (PostGIS)")]
    end
        AuthSvc["Auth Service (Java)"]
        CoreSvc["Core/Order Service (Java)"]
        TrackSvc["Tracking Service (NodeJS)"]
        AdminSvc["Backoffice Service (PHP)"]
    end


    %% --- Conex√µes ---
    MobileApp -->|"HTTPS / JSON"| Nginx
    AdminWeb -->|"HTTPS / JSON"| Nginx

    Nginx -->|"1. Validate Token"| AuthSvc
    Nginx -->|"2. Proxy Request"| CoreSvc
    Nginx -->|"2. Proxy Request"| TrackSvc
    Nginx -->|"2. Proxy Request"| AdminSvc

    CoreSvc -->|"CRUD"| DB_Core
    AdminSvc -->|"Read/Write"| DB_Core

    %% Fluxos Ass√≠ncronos
    AuthSvc -.->|"Session Data"| Redis
    linkStyle 8 stroke:#1565c0,stroke-width:2px,stroke-dasharray: 5 5;

    CoreSvc -.->|"Pub: OrderCreated"| RabbitMQ
    linkStyle 9 stroke:#f57f17,stroke-width:2px,stroke-dasharray: 5 5;

    RabbitMQ -.->|"Sub: CreateTracking"| TrackSvc
    linkStyle 10 stroke:#f57f17,stroke-width:2px,stroke-dasharray: 5 5;

    TrackSvc -.->|"1. Hot Write (Geo)"| Redis
    linkStyle 11 stroke:#2e7d32,stroke-width:2px,stroke-dasharray: 5 5;

    TrackSvc --->|"2. Batch Write (Cron)"| DB_Geo

    class MobileApp,AdminWeb frontend;
    class Nginx gateway;
    class AuthSvc,CoreSvc javaSvc;
    class TrackSvc nodeSvc;
    class AdminSvc phpSvc;
    class DB_Core,DB_Geo,Redis database;
    class RabbitMQ queue;

    CoreSvc ~~~ DB_Core
```

## 3. Stack Tecnol√≥gico

A escolha segue Polyglot Programming, usando a melhor ferramenta para cada responsabilidade.

### Componentes, Tecnologias e Responsabilidades

| Componente       | Tecnologia           | Responsabilidade                                  |
| :--------------- | :------------------- | :------------------------------------------------ |
| API Gateway      | Nginx                | Roteamento, SSL, Rate Limiting                    |
| Auth Service     | Java (Spring Boot)   | Autentica√ß√£o e JWT                                |
| Core Service     | Java (Spring Boot)   | Pedidos e pagamentos                              |
| Tracking Service | Node.js (NestJS)     | Telemetria e geo-c√°lculos                         |
| Backoffice       | PHP                  | Administra√ß√£o e relat√≥rios                        |
| Bancos           | PostgreSQL + PostGIS | Dados relacionais e espaciais                     |
| Cache/Buffer     | Redis                | Cache, geolocaliza√ß√£o em tempo real, write-behind |
| Mensageria       | RabbitMQ             | Comunica√ß√£o ass√≠ncrona                            |

## 4. Decis√µes Estrat√©gicas (Key Design Decisions)

### 4.1. Autentica√ß√£o Centralizada (Gateway Offloading)

**Decis√£o:** O Nginx (ou API Gateway) valida o token JWT via sub-request (`auth_request`) antes de encaminhar para os microsservi√ßos.

**Benef√≠cio:** Os servi√ßos internos (`fleet-orders`, `fleet-tracking`) n√£o precisam implementar l√≥gica de valida√ß√£o de token, focando apenas no dom√≠nio. Permite revoga√ß√£o centralizada e simplifica a gest√£o de depend√™ncias de seguran√ßa.

### 4.2. Telemetria em Alta Frequ√™ncia (Write-Behind Pattern)

**Problema:** Milhares de coordenadas de entregadores chegando a cada 3 segundos gerariam gargalo de I/O se fossem inseridas linha a linha no banco.

**Solu√ß√£o:**

- **Entrada:** O servi√ßo de Tracking grava no Redis (Geo Set/Lists) para lat√™ncia sub-milissegundo.
- **Buffer:** O Redis atua como um buffer tempor√°rio de alta velocidade.
- **Persist√™ncia:** Um Cron Job (Worker) coleta esses dados e faz Batch Inserts no PostGIS a cada 60 segundos.

### 4.3. Consist√™ncia Eventual e Confiabilidade (Transactional Outbox)

**Problema:** O risco de "Dual Write" (salvar no banco e falhar ao enviar para o RabbitMQ).

**Solu√ß√£o:** Implementa√ß√£o do **Transactional Outbox Pattern** no `fleet-auth`. O evento √© salvo na mesma transa√ß√£o do banco de dados e um polling publisher garante o envio para o RabbitMQ, assegurando que nenhuma mensagem de neg√≥cio seja perdida em caso de falha de rede.

## 5. Modelagem de Dados

### db_fleet_tracking

> Modelagem voltada para rastreamento de entregadores, eventos e zonas de atua√ß√£o. Utiliza PostGIS para dados espaciais e integra√ß√µes com o servi√ßo de pedidos via UUID.

```mermaid
erDiagram
    DRIVERS ||--|{ DRIVER_LOCATIONS : "tracks location"
    DRIVERS ||--|{ DRIVER_AVAILABILITY_ZONES : "operates in"
    DRIVERS ||--o{ ORDER_TRACKING_EVENTS : "generates events"

    DRIVERS {
        uuid id PK
        varchar name
        varchar phone
        varchar cnh
        varchar vehicle_plate
        boolean is_online
        boolean is_available
        uuid current_order_id "Refer√™ncia ao pedido atual (integra√ß√£o externa)"
        geography location "Localiza√ß√£o atual (PostGIS POINT)"
        timestamp last_location_update "√öltima atualiza√ß√£o de localiza√ß√£o"
        int total_deliveries "Total de entregas realizadas"
        decimal rating "M√©dia de avalia√ß√µes"
    }

    DRIVER_LOCATIONS {
        uuid id PK
        uuid driver_id FK "Refer√™ncia ao entregador"
        uuid order_id "Refer√™ncia ao pedido (integra√ß√£o externa)"
        decimal latitude
        decimal longitude
        geography location "Posi√ß√£o registrada (PostGIS POINT)"
        decimal speed "Velocidade no momento"
        timestamp recorded_at "Data/hora do registro"
    }

    DRIVER_AVAILABILITY_ZONES {
        uuid id PK
        uuid driver_id FK "Refer√™ncia ao entregador"
        varchar zone_name "Nome da zona de atua√ß√£o"
        geography zone_polygon "√Årea de atua√ß√£o (PostGIS POLYGON)"
        boolean active "Zona ativa"
    }

    ORDER_TRACKING_EVENTS {
        uuid id PK
        uuid order_id "Refer√™ncia ao pedido (integra√ß√£o externa)"
        uuid driver_id FK "Refer√™ncia ao entregador"
        varchar event_type "Ex: 'pickup', 'delivered'"
        decimal latitude
        decimal longitude
        geography location "Localiza√ß√£o do evento"
        jsonb metadata "Informa√ß√µes adicionais do evento"
        timestamp created_at "Data/hora do evento"
    }
```

### db_fleet_orders

> Modelagem voltada para pedidos, clientes, lojas e hist√≥rico de status. Integra√ß√£o com rastreamento via UUID, snapshots para auditoria e campos explicativos.

#### auth_schema

```mermaid
erDiagram
    USERS ||--o{ REFRESH_TOKENS : has
    USERS ||--o{ USER_ROLES : assigned
    ROLES ||--o{ USER_ROLES : contains

    USERS {
        uuid id PK
        varchar name
        varchar email
        varchar password
        varchar user_type
        boolean enabled
        boolean account_non_expired
        boolean account_non_locked
        boolean credentials_non_expired
        timestamp created_at
        timestamp updated_at
    }

    ROLES {
        uuid id PK
        varchar name
        timestamp created_at
    }

    USER_ROLES {
        uuid user_id PK
        uuid role_id PK
        timestamp assigned_at
    }

    REFRESH_TOKENS {
        uuid id PK
        varchar token_hash
        uuid user_id FK
        uuid parent_id
        uuid session_id
        timestamp expires_at
        boolean revoked
        boolean used
        timestamp created_at
        timestamp updated_at
        bigint version
    }
```

---

#### orders_schema

```mermaid
erDiagram
    SHOPS ||--o{ ITEMS : sells
    SHOPS ||--o{ ORDERS : "receives from"
    CLIENTS ||--o{ ORDERS : places
    CLIENTS ||--o{ PAYMENT_METHODS : "has methods"
    ORDERS ||--o{ ORDER_ITEMS : contains
    ITEMS ||--o{ ORDER_ITEMS : "included in"
    ORDERS ||--o{ ORDER_STATUS_HISTORY : "status changes"

    PRICING_CONFIG {
        uuid id PK
        varchar region
        decimal base_fee
        decimal price_per_km
        decimal surge_multiplier
    }

    SHOPS {
        uuid id PK
        uuid owner_user_id "ID do usu√°rio (auth.users)"
        varchar name
        varchar address
        decimal latitude
        decimal longitude
        geography location
        boolean active
    }

    CLIENTS {
        uuid id PK
        uuid user_id "ID do usu√°rio (auth.users)"
        varchar cpf
        uuid default_payment_method_id
        boolean active
    }

    ITEMS {
        uuid id PK
        uuid shop_id FK
        varchar name
        decimal price
        boolean active
    }

    ORDERS {
        uuid id PK
        uuid client_id FK
        uuid shop_id FK
        uuid driver_user_id "Usu√°rio externo (auth.users)"
        varchar pickup_address
        decimal pickup_latitude
        decimal pickup_longitude
        varchar delivery_address
        decimal delivery_latitude
        decimal delivery_longitude
        geography pickup_location
        geography delivery_location
        decimal distance_km
        decimal total
        varchar status
        varchar driver_name
        varchar driver_phone
    }

    PAYMENT_METHODS {
        uuid id PK
        uuid client_id FK
        varchar type
        varchar card_last4
        boolean is_default
    }

    ORDER_ITEMS {
        uuid id PK
        uuid order_id FK
        uuid item_id FK
        int quantity
        decimal price_at_moment
    }

    ORDER_STATUS_HISTORY {
        uuid id PK
        uuid order_id FK
        varchar from_status
        varchar to_status
        uuid changed_by_user_id "auth.users (refer√™ncia l√≥gica)"
        timestamp changed_at
    }

```

## 6. ADR ‚Äì Registros de Decis√µes Arquiteturais

### ADR 001: Processamento da Localiza√ß√£o do Entregador

**Decis√£o:** Utilizar processamento em lote (Batch Work) com Redis e PostGIS.

**Justificativa:** O volume de escrita de GPS √© alto demais para o banco relacional suportar em tempo real (OLTP). O processamento em lote reduz a carga de I/O no disco e evita locks desnecess√°rios na tabela de hist√≥rico.

### ADR 002: Mensageria (RabbitMQ vs Kafka)

**Decis√£o:** Adotar RabbitMQ.

**Justificativa:** Para o est√°gio atual e volumetria do `fleet-auth` e notifica√ß√µes, o RabbitMQ oferece menor complexidade operacional, suporte nativo a prioridade e roteamento flex√≠vel (exchanges), al√©m de garantir confirma√ß√£o granular de entrega (ACKs). O Kafka seria overkill e adicionaria complexidade acidental neste momento.

### ADR 003: Separa√ß√£o de Bancos de Dados

**Decis√£o:** Utilizar bases de dados fisicamente separadas para Dom√≠nios distintos (`db_fleet_auth`, `db_fleet_orders`, `db_fleet_tracking`).

**Justificativa:**

- **Isolamento de Falhas:** Um pico de carga no rastreamento n√£o derruba o login dos usu√°rios.
- **Seguran√ßa:** Dados sens√≠veis (senhas) ficam inacess√≠veis ao servi√ßo de pedidos.
- **Escalabilidade:** Permite escalar o hardware do banco de geolocaliza√ß√£o (PostGIS) independentemente do banco relacional padr√£o.

### ADR 004: Garantia de Entrega (Idempot√™ncia)

**Decis√£o:** Consumidores devem ser Idempotentes.

**Justificativa:** Devido ao uso do Outbox Pattern e √† natureza de redes distribu√≠das ("at-least-once delivery"), mensagens podem chegar duplicadas. Os servi√ßos consumidores utilizam tabelas de controle ou chaves de neg√≥cio √∫nicas para descartar duplicatas silenciosamente.

## 7. Trade-offs (Limita√ß√µes Aceitas)

- **Consist√™ncia Eventual no Hist√≥rico:** O trajeto do entregador pode levar at√© 60 segundos para aparecer no hist√≥rico permanente (PostGIS), embora a posi√ß√£o atual (Redis) seja em tempo real.

- **Depend√™ncia Cr√≠tica do Redis:** Se o Redis falhar e n√£o houver persist√™ncia em disco (AOF/RDB) configurada, pode haver perda de at√© 1 minuto de dados de telemetria (buffer).

- **Complexidade de Observabilidade:** Com a separa√ß√£o em microsservi√ßos e bancos distintos, o rastreamento de erros exige ferramentas de Distributed Tracing (OpenTelemetry/Micrometer) para correlacionar logs entre Java, Node.js e banco de dados.

- **Integridade Referencial:** A separa√ß√£o dos bancos remove as Foreign Keys entre Pedidos e Usu√°rios, exigindo que a consist√™ncia seja garantida via aplica√ß√£o (eventos de compensa√ß√£o).

# üèóÔ∏è Arquitetura do Sistema - Plataforma Log√≠stica

Este documento detalha as decis√µes de arquitetura, stack tecnol√≥gico e estrat√©gias de dados adotadas para o desenvolvimento da plataforma de entregas.

## 1. Contexto do Sistema (C4 Model - N√≠vel 1)

Vis√£o macro das intera√ß√µes entre os usu√°rios, a plataforma e sistemas externos.

```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#fff', 'edgeLabelBackground':'#ffffff', 'tertiaryColor': 'transparent', 'background': 'transparent', 'lineColor': '#000'}}}%%
graph TD
    classDef person fill:#08427b,stroke:#052e56,color:#fff,rx:10,ry:10;
    classDef system fill:#1168bd,stroke:#0b4884,color:#fff,rx:10,ry:10;
    classDef external fill:#999999,stroke:#6b6b6b,color:#fff,rx:10,ry:10;

    User[("Cliente / Entregador")]:::person
    Admin[("Administrador")]:::person

    System[("Plataforma de Log√≠stica")]:::system

    Maps[("Open Street Map")]:::external

    User -->|"Usa o App para pedidos/entregas"| System
    Admin -->|"Gerencia opera√ß√µes"| System

    System -->|"Geocodifica√ß√£o e Rotas"| Maps
```

## 2. Arquitetura T√©cnica (C4 Model - N√≠vel 2)

O sistema segue uma arquitetura de Microsservi√ßos orientada a eventos.
O fluxo de dados prioriza:

### Seguran√ßa no edge (API Gateway)

### Performance na escrita de geolocaliza√ß√£o (Write-Behind)

```mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#fff', 'edgeLabelBackground':'#ffffff', 'tertiaryColor': 'transparent', 'background': 'transparent', 'lineColor': '#ffffff'}}}%%
graph TD
    %% --- Defini√ß√£o de Estilos (Classes) ---
    classDef frontend fill:#e1bee7,stroke:#4a148c,stroke-width:2px,color:#000,rx:10,ry:10;
    classDef gateway fill:#37474f,stroke:#000,stroke-width:2px,color:#fff,shape:hexagon;
    classDef javaSvc fill:#bbdefb,stroke:#0d47a1,stroke-width:2px,color:#000;
    classDef nodeSvc fill:#c8e6c9,stroke:#1b5e20,stroke-width:2px,color:#000;
    classDef phpSvc fill:#ffe0b2,stroke:#e65100,stroke-width:2px,color:#000;
    classDef database fill:#cfd8dc,stroke:#455a64,stroke-width:2px,color:#000,shape:cylinder;
    classDef queue fill:#fff9c4,stroke:#fbc02d,stroke-width:2px,color:#000,stroke-dasharray: 5 5;

    %% --- Estrutura do Diagrama ---
    subgraph Clients ["üì± Frontends (SPA Angular)"]
        direction LR
        MobileApp("App (Cliente/Entregador)")
        AdminWeb("Backoffice Web (Admin)")
    end

    subgraph Edge ["üõ°Ô∏è Edge Layer"]
        Nginx{{"API Gateway (Nginx)"}}
    end

    subgraph Services ["‚öôÔ∏è Backend Microservices"]
    subgraph Data ["üíæ Persistence & Messaging"]
        Redis[("Redis (Cache & Buffer)")]
        RabbitMQ[["RabbitMQ (Events)"]]
        DB_Core[("DB_Orders (Postgres)")]
        DB_Geo[("DB_Tracking (PostGIS)")]
    end
        AuthSvc["Auth Service (Java)"]
        CoreSvc["Core/Order Service (Java)"]
        TrackSvc["Tracking Service (NodeJS)"]
        AdminSvc["Backoffice Service (PHP)"]
    end


    %% --- Conex√µes ---
    MobileApp -->|"HTTPS / JSON"| Nginx
    AdminWeb -->|"HTTPS / JSON"| Nginx

    Nginx -->|"1. Validate Token"| AuthSvc
    Nginx -->|"2. Proxy Request"| CoreSvc
    Nginx -->|"2. Proxy Request"| TrackSvc
    Nginx -->|"2. Proxy Request"| AdminSvc

    CoreSvc -->|"CRUD"| DB_Core
    AdminSvc -->|"Read/Write"| DB_Core

    %% Fluxos Ass√≠ncronos
    AuthSvc -.->|"Session Data"| Redis
    linkStyle 8 stroke:#1565c0,stroke-width:2px,stroke-dasharray: 5 5;

    CoreSvc -.->|"Pub: OrderCreated"| RabbitMQ
    linkStyle 9 stroke:#f57f17,stroke-width:2px,stroke-dasharray: 5 5;

    RabbitMQ -.->|"Sub: CreateTracking"| TrackSvc
    linkStyle 10 stroke:#f57f17,stroke-width:2px,stroke-dasharray: 5 5;

    TrackSvc -.->|"1. Hot Write (Geo)"| Redis
    linkStyle 11 stroke:#2e7d32,stroke-width:2px,stroke-dasharray: 5 5;

    TrackSvc --->|"2. Batch Write (Cron)"| DB_Geo

    class MobileApp,AdminWeb frontend;
    class Nginx gateway;
    class AuthSvc,CoreSvc javaSvc;
    class TrackSvc nodeSvc;
    class AdminSvc phpSvc;
    class DB_Core,DB_Geo,Redis database;
    class RabbitMQ queue;

    CoreSvc ~~~ DB_Core
```

## 3. Stack Tecnol√≥gico

A escolha segue Polyglot Programming, usando a melhor ferramenta para cada responsabilidade.

### Componentes, Tecnologias e Responsabilidades

| Componente       | Tecnologia           | Responsabilidade                                  |
| :--------------- | :------------------- | :------------------------------------------------ |
| API Gateway      | Nginx                | Roteamento, SSL, Rate Limiting                    |
| Auth Service     | Java (Spring Boot)   | Autentica√ß√£o e JWT                                |
| Core Service     | Java (Spring Boot)   | Pedidos e pagamentos                              |
| Tracking Service | Node.js (NestJS)     | Telemetria e geo-c√°lculos                         |
| Backoffice       | PHP                  | Administra√ß√£o e relat√≥rios                        |
| Bancos           | PostgreSQL + PostGIS | Dados relacionais e espaciais                     |
| Cache/Buffer     | Redis                | Cache, geolocaliza√ß√£o em tempo real, write-behind |
| Mensageria       | RabbitMQ             | Comunica√ß√£o ass√≠ncrona                            |

## 4. Decis√µes Estrat√©gicas (Key Design Decisions)

### 4.1. Autentica√ß√£o no Gateway (Token Introspection)

O Nginx valida o token via auth_request.

Servicios internos n√£o precisam validar JWT.

Permite revoga√ß√£o centralizada e menor complexidade.

### 4.2. Telemetria em Alta Frequ√™ncia (Node.js + PostGIS)

Problema: milhares de coordenadas chegando a cada 3s ‚Üí N√£o fazer INSERT direto.

Solu√ß√£o: Write-Behind Pattern

Entrada: Tracking grava no Redis (Geo Set) ‚Üí lat√™ncia sub-ms.

Buffer: Redis armazena coordenadas em lista.

Persist√™ncia: Cron job faz batch inserts no PostGIS a cada 60s.

## 5. Modelagem de Dados

### db_fleet_tracking

> Modelagem voltada para rastreamento de entregadores, eventos e zonas de atua√ß√£o. Utiliza PostGIS para dados espaciais e integra√ß√µes com o servi√ßo de pedidos via UUID.

```mermaid
erDiagram
    DRIVERS ||--|{ DRIVER_LOCATIONS : "tracks location"
    DRIVERS ||--|{ DRIVER_AVAILABILITY_ZONES : "operates in"
    DRIVERS ||--o{ ORDER_TRACKING_EVENTS : "generates events"

    DRIVERS {
        uuid id PK
        varchar name
        varchar phone
        varchar cnh
        varchar vehicle_plate
        boolean is_online
        boolean is_available
        uuid current_order_id "Refer√™ncia ao pedido atual (integra√ß√£o externa)"
        geography location "Localiza√ß√£o atual (PostGIS POINT)"
        timestamp last_location_update "√öltima atualiza√ß√£o de localiza√ß√£o"
        int total_deliveries "Total de entregas realizadas"
        decimal rating "M√©dia de avalia√ß√µes"
    }

    DRIVER_LOCATIONS {
        uuid id PK
        uuid driver_id FK "Refer√™ncia ao entregador"
        uuid order_id "Refer√™ncia ao pedido (integra√ß√£o externa)"
        decimal latitude
        decimal longitude
        geography location "Posi√ß√£o registrada (PostGIS POINT)"
        decimal speed "Velocidade no momento"
        timestamp recorded_at "Data/hora do registro"
    }

    DRIVER_AVAILABILITY_ZONES {
        uuid id PK
        uuid driver_id FK "Refer√™ncia ao entregador"
        varchar zone_name "Nome da zona de atua√ß√£o"
        geography zone_polygon "√Årea de atua√ß√£o (PostGIS POLYGON)"
        boolean active "Zona ativa"
    }

    ORDER_TRACKING_EVENTS {
        uuid id PK
        uuid order_id "Refer√™ncia ao pedido (integra√ß√£o externa)"
        uuid driver_id FK "Refer√™ncia ao entregador"
        varchar event_type "Ex: 'pickup', 'delivered'"
        decimal latitude
        decimal longitude
        geography location "Localiza√ß√£o do evento"
        jsonb metadata "Informa√ß√µes adicionais do evento"
        timestamp created_at "Data/hora do evento"
    }
```

### db_fleet_orders

> Modelagem voltada para pedidos, clientes, lojas e hist√≥rico de status. Integra√ß√£o com rastreamento via UUID, snapshots para auditoria e campos explicativos.

#### auth_schema

```mermaid
erDiagram
    USERS ||--o{ REFRESH_TOKENS : has
    USERS ||--o{ USER_ROLES : assigned
    ROLES ||--o{ USER_ROLES : contains

    USERS {
        uuid id PK
        varchar name
        varchar email
        varchar password
        varchar user_type
        boolean enabled
        boolean account_non_expired
        boolean account_non_locked
        boolean credentials_non_expired
        timestamp created_at
        timestamp updated_at
    }

    ROLES {
        uuid id PK
        varchar name
        timestamp created_at
    }

    USER_ROLES {
        uuid user_id PK
        uuid role_id PK
        timestamp assigned_at
    }

    REFRESH_TOKENS {
        uuid id PK
        varchar token_hash
        uuid user_id FK
        uuid parent_id
        uuid session_id
        timestamp expires_at
        boolean revoked
        boolean used
        timestamp created_at
        timestamp updated_at
        bigint version
    }
```

---

#### orders_schema

```mermaid
erDiagram
    SHOPS ||--o{ ITEMS : sells
    SHOPS ||--o{ ORDERS : "receives from"
    CLIENTS ||--o{ ORDERS : places
    CLIENTS ||--o{ PAYMENT_METHODS : "has methods"
    ORDERS ||--o{ ORDER_ITEMS : contains
    ITEMS ||--o{ ORDER_ITEMS : "included in"
    ORDERS ||--o{ ORDER_STATUS_HISTORY : "status changes"

    PRICING_CONFIG {
        uuid id PK
        varchar region
        decimal base_fee
        decimal price_per_km
        decimal surge_multiplier
    }

    SHOPS {
        uuid id PK
        uuid owner_user_id "ID do usu√°rio (auth.users)"
        varchar name
        varchar address
        decimal latitude
        decimal longitude
        geography location
        boolean active
    }

    CLIENTS {
        uuid id PK
        uuid user_id "ID do usu√°rio (auth.users)"
        varchar cpf
        uuid default_payment_method_id
        boolean active
    }

    ITEMS {
        uuid id PK
        uuid shop_id FK
        varchar name
        decimal price
        boolean active
    }

    ORDERS {
        uuid id PK
        uuid client_id FK
        uuid shop_id FK
        uuid driver_user_id "Usu√°rio externo (auth.users)"
        varchar pickup_address
        decimal pickup_latitude
        decimal pickup_longitude
        varchar delivery_address
        decimal delivery_latitude
        decimal delivery_longitude
        geography pickup_location
        geography delivery_location
        decimal distance_km
        decimal total
        varchar status
        varchar driver_name
        varchar driver_phone
    }

    PAYMENT_METHODS {
        uuid id PK
        uuid client_id FK
        varchar type
        varchar card_last4
        boolean is_default
    }

    ORDER_ITEMS {
        uuid id PK
        uuid order_id FK
        uuid item_id FK
        int quantity
        decimal price_at_moment
    }

    ORDER_STATUS_HISTORY {
        uuid id PK
        uuid order_id FK
        varchar from_status
        varchar to_status
        uuid changed_by_user_id "auth.users (refer√™ncia l√≥gica)"
        timestamp changed_at
    }

```

## 6. ADR ‚Äì Registros de Decis√µes

### Redis ‚Äì Processamento da Localiza√ß√£o do Entregador

**Decis√£o:** Utilizar processamento em lote (Batch Work).

**Justificativa:** O processamento em lote permite agrupar e salvar dados periodicamente, reduzindo a carga sobre o banco de dados e otimizando a performance do sistema.

### RabbitMQ vs Kafka

**Decis√£o:** Adotar RabbitMQ.

**Justificativa:** RabbitMQ foi escolhido devido ao suporte para roteamento complexo, confirma√ß√£o granular de mensagens (ACK), al√©m de apresentar menor complexidade operacional em compara√ß√£o ao Kafka.

### Separa√ß√£o de Bancos

**Decis√£o:** Utilizar bancos separados para pedidos (`db_fleet_order`) e rastreamento (`db_fleet_tracking`).

**Justificativa:** A separa√ß√£o l√≥gica permite escalar o armazenamento e processamento de geodados de forma independente, sem impactar o banco principal de pedidos, garantindo maior flexibilidade e performance para cada tipo de dado.

## 7. Trade-offs

Consist√™ncia eventual de at√© 60s no hist√≥rico.

Depend√™ncia forte do Redis (poss√≠vel perda de 1min de buffer)

Observabilidade distribu√≠da necess√°ria (Java + Node + PHP).
